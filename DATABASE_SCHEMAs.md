# Supabase Database Schema

This file contains the necessary SQL to set up the database tables for the dating application in your Supabase project.

## Instructions

1.  Navigate to your Supabase project dashboard.
2.  In the left sidebar, click on the "SQL Editor" icon.
3.  Click "New query".
4.  Copy the SQL code below and paste it into the SQL editor.
5.  Click "Run" to execute the query and create the tables and functions.

---

## Part 1: Profiles Table

This table stores the public profile information for each user.

```sql
-- Create the ringtones table first if it doesn't exist
CREATE TABLE IF NOT EXISTS public.ringtones (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  url TEXT NOT NULL
);

-- Seed with some default ringtones
INSERT INTO public.ringtones (name, url) VALUES
('Classic Phone', '/ringtones/classic.mp3'),
('Digital Alarm', '/ringtones/digital.mp3')
ON CONFLICT (name) DO NOTHING;


-- Create the profiles table
CREATE TABLE public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  name TEXT,
  age INT,
  bio TEXT,
  photos TEXT[],
  interests TEXT[],
  is_verified BOOLEAN DEFAULT FALSE,
  subscription_tier TEXT DEFAULT 'free' NOT NULL,
  ringtone_id INT REFERENCES public.ringtones(id) DEFAULT 1,
  last_seen TIMESTAMPTZ DEFAULT now() NOT NULL,
  profile_score INT DEFAULT 0 NOT NULL,
  kyc_status TEXT DEFAULT 'not_started' NOT NULL -- ('not_started', 'pending', 'approved', 'rejected')
);

-- Add comments for clarity
COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';

-- Enable Row Level Security (RLS) for the profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
CREATE POLICY "Allow public read access" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Allow individual insert" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow individual update" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- Add a 'role' column for admin privileges
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS role TEXT DEFAULT 'user' NOT NULL;

-- Create a helper function to get a user's role
CREATE OR REPLACE FUNCTION public.get_user_role(p_user_id UUID)
RETURNS TEXT
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT role FROM public.profiles WHERE id = p_user_id;
$$;

-- Add a phone_number column for contact matching
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS phone_number TEXT UNIQUE;
```

---

## Part 2: Likes and Matches Tables

These tables handle the matchmaking logic.

```sql
-- Create the likes table
CREATE TABLE public.likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  liker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  liked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(liker_id, liked_id)
);

-- Enable RLS for likes
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

-- Policies for likes table
CREATE POLICY "Allow individual insert for likes" ON public.likes FOR INSERT WITH CHECK (auth.uid() = liker_id);
CREATE POLICY "Allow individual read for likes" ON public.likes FOR SELECT USING (auth.uid() = liker_id OR auth.uid() = liked_id);


-- Create the matches table
CREATE TABLE public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user1_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  user2_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(user1_id, user2_id)
);

-- Enable RLS for matches
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;

-- Policies for matches table
CREATE POLICY "Allow individual read for matches" ON public.matches FOR SELECT USING (auth.uid() = user1_id OR auth.uid() = user2_id);
```

---

## Part 3: Database Function for Matching

This function handles the logic of creating a `like` and checking for a `match`.

```sql
-- Function to create a like and check for a match
CREATE OR REPLACE FUNCTION public.create_like_and_match(p_liked_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_liker_id UUID := auth.uid();
  v_match_exists BOOLEAN;
  v_new_match_id BIGINT;
BEGIN
  -- Insert the new like
  INSERT INTO public.likes (liker_id, liked_id)
  VALUES (v_liker_id, p_liked_id);

  -- Check if the other user has already liked the current user
  SELECT EXISTS (
    SELECT 1 FROM public.likes WHERE liker_id = p_liked_id AND liked_id = v_liker_id
  ) INTO v_match_exists;

  -- If a match exists, create a new match entry
  IF v_match_exists THEN
    INSERT INTO public.matches (user1_id, user2_id)
    VALUES (v_liker_id, p_liked_id)
    ON CONFLICT (user1_id, user2_id) DO NOTHING
    RETURNING id INTO v_new_match_id;

    RETURN json_build_object('matched', true, 'match_id', v_new_match_id);
  ELSE
    RETURN json_build_object('matched', false);
  END IF;
END;
$$;
```

---

## Part 4: Posts Table for Timeline/Feed

This table stores posts made by users.

```sql
-- Create the posts table
CREATE TABLE public.posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  text_content TEXT,
  image_url TEXT
);

-- Enable RLS for posts
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

-- Policies for posts table
CREATE POLICY "Allow public read access for posts" ON public.posts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for posts" ON public.posts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual update for posts" ON public.posts FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual delete for posts" ON public.posts FOR DELETE USING (auth.uid() = user_id);

-- Add columns for post boosting
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS is_boosted BOOLEAN DEFAULT false NOT NULL;
ALTER TABLE public.posts ADD COLUMN IF NOT EXISTS boost_expires_at TIMESTAMPTZ;
```

---

## Part 5: Messages Table for Chat

This table stores all chat messages between matched users.

```sql
-- Create the messages table
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,

  -- Conversation link
  match_id BIGINT REFERENCES public.matches(id) ON DELETE CASCADE,
  group_id BIGINT REFERENCES public.groups(id) ON DELETE CASCADE,

  -- Message content
  message_type TEXT NOT NULL DEFAULT 'text', -- 'text', 'image', 'video', 'audio'
  text_content TEXT,
  media_url TEXT,
  is_edited BOOLEAN DEFAULT false NOT NULL,
  is_view_once BOOLEAN DEFAULT false NOT NULL,
  is_viewed BOOLEAN DEFAULT false NOT NULL,

  -- Ensure one conversation link, not both
  CONSTRAINT conversation_check CHECK (
    (match_id IS NOT NULL AND group_id IS NULL) OR
    (match_id IS NULL AND group_id IS NOT NULL)
  )
);

-- Enable RLS for messages
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Function to check if a user is part of a match
CREATE OR REPLACE FUNCTION public.is_in_match(p_match_id BIGINT, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.matches
    WHERE id = p_match_id AND (user1_id = p_user_id OR user2_id = p_user_id)
  );
$$;

-- Policies for messages table
CREATE POLICY "Allow access to members of the conversation" ON public.messages FOR ALL
USING (
  (match_id IS NOT NULL AND public.is_in_match(match_id, auth.uid())) OR
  (group_id IS NOT NULL AND public.is_in_group(group_id, auth.uid()))
)
WITH CHECK (
  ( -- Check for insert/update
    (match_id IS NOT NULL AND public.is_in_match(match_id, auth.uid())) OR
    (group_id IS NOT NULL AND public.is_in_group(group_id, auth.uid()))
  ) AND
  sender_id = auth.uid()
);
```

---

## Part 6: Monetization Tables & Functions

These tables provide the foundation for the wallet and subscription system.

```sql
-- Create a new ENUM type for currency
CREATE TYPE currency_type AS ENUM ('USD', 'NGN', 'EUR', 'GBP');

-- Create the wallets table
CREATE TABLE public.wallets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  currency currency_type NOT NULL,
  balance NUMERIC(12, 2) NOT NULL DEFAULT 0.00,
  UNIQUE(user_id, currency)
);

-- Enable RLS for wallets
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;

-- Policies for wallets
CREATE POLICY "Allow individual read access for wallets" ON public.wallets FOR SELECT USING (auth.uid() = user_id);


-- Create the transactions table
CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_id BIGINT NOT NULL REFERENCES public.wallets(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  transaction_type TEXT NOT NULL, -- e.g., 'deposit', 'gift_sent', 'subscription_fee'
  amount NUMERIC(12, 2) NOT NULL,
  description TEXT
);

-- Enable RLS for transactions
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- Policies for transactions
CREATE POLICY "Allow individual read access for transactions" ON public.transactions FOR SELECT USING (
  EXISTS (SELECT 1 FROM wallets WHERE id = wallet_id AND user_id = auth.uid())
);


-- Function to create wallets for a new user automatically
CREATE OR REPLACE FUNCTION public.create_user_wallets()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.wallets (user_id, currency)
  VALUES
    (NEW.id, 'NGN'),
    (NEW.id, 'USD'),
    (NEW.id, 'EUR'),
    (NEW.id, 'GBP');
  RETURN NEW;
END;
$$;

-- Trigger to call the function when a new profile is created
CREATE TRIGGER on_profile_created_wallets
  AFTER INSERT ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.create_user_wallets();

-- Create gift_types table
CREATE TABLE public.gift_types (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  cost NUMERIC(10, 2) NOT NULL,
  currency currency_type NOT NULL DEFAULT 'NGN',
  icon_url TEXT
);

-- Seed some default gifts
INSERT INTO public.gift_types (name, cost, currency, icon_url) VALUES
('Rose', 500.00, 'NGN', '/gifts/rose.png'),
('Diamond', 5000.00, 'NGN', '/gifts/diamond.png'),
('Teddy Bear', 2500.00, 'NGN', '/gifts/bear.png')
ON CONFLICT (name) DO NOTHING;

-- Create user_gifts table
CREATE TABLE public.user_gifts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  gift_type_id INT NOT NULL REFERENCES public.gift_types(id)
);

-- Enable RLS
ALTER TABLE public.user_gifts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read on gifts" ON public.user_gifts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for gifts" ON public.user_gifts FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- Function to handle the transaction for boosting a post
CREATE OR REPLACE FUNCTION public.boost_post_transaction(
  p_post_id BIGINT,
  p_user_id UUID,
  p_wallet_id BIGINT,
  p_boost_cost NUMERIC,
  p_boost_expires_at TIMESTAMPTZ
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- 1. Deduct the cost from the user's wallet
  UPDATE public.wallets
  SET balance = balance - p_boost_cost
  WHERE id = p_wallet_id AND user_id = p_user_id;

  -- 2. Log the transaction
  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES (p_wallet_id, 'post_boost', p_boost_cost, 'Boosted post ID: ' || p_post_id);

  -- 3. Update the post to mark it as boosted
  UPDATE public.posts
  SET
    is_boosted = true,
    boost_expires_at = p_boost_expires_at
  WHERE id = p_post_id AND user_id = p_user_id;
END;
$$;
```

---

## Part 7: Core Social Features Tables

```sql
-- Create the followers table
CREATE TABLE public.followers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  follower_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  following_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(follower_id, following_id)
);

-- Enable RLS
ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow public read on followers" ON public.followers FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for followers" ON public.followers FOR INSERT WITH CHECK (auth.uid() = follower_id);
CREATE POLICY "Allow individual delete for followers" ON public.followers FOR DELETE USING (auth.uid() = follower_id);


-- Create the blocked_users table
CREATE TABLE public.blocked_users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  blocker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  blocked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(blocker_id, blocked_id)
);

-- Enable RLS
ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual access for blocked users" ON public.blocked_users FOR ALL
USING (auth.uid() = blocker_id)
WITH CHECK (auth.uid() = blocker_id);

-- Create the reports table
CREATE TABLE public.reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  reporter_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reported_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reason TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'resolved', 'dismissed'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual insert for reports" ON public.reports FOR INSERT
WITH CHECK (auth.uid() = reporter_id);
-- Note: An admin role would be needed to read/update reports. This is a basic setup.
```

---

## Part 8: KYC (Know Your Customer) Tables

```sql
-- Create the kyc_documents table
CREATE TABLE public.kyc_documents (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  document_type TEXT NOT NULL, -- e.g., 'passport', 'nin', 'bvn'
  document_url TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  reviewed_at TIMESTAMPTZ
);

-- Enable RLS
ALTER TABLE public.kyc_documents ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual to manage their own KYC docs" ON public.kyc_documents FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
```

---

## Supabase Storage Setup

### For Post Images
1.  Go to the "Storage" section in your Supabase dashboard and create a **public** bucket named `post-images`.

### For Chat Media (Images, Videos, Audio)
1.  Create another **public** bucket named `chat-media`.

### For Ringtones
1. Create a new **public** bucket named `ringtones`.

### For KYC Documents
1. Create a **private** bucket named `kyc-documents`. This is crucial for security.
2. Add policies to allow authenticated users to upload to their own folder:
   ```sql
   CREATE POLICY "Allow authenticated KYC uploads" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'kyc-documents' AND (storage.foldername(name))[1] = auth.uid()::text);
   CREATE POLICY "Allow individual read on KYC docs" ON storage.objects FOR SELECT USING (bucket_id = 'kyc-documents' AND (storage.foldername(name))[1] = auth.uid()::text);
   ```

---

## Part 9: Custom Advertisements Table

This table stores internal advertisements that can be displayed on the platform.

```sql
-- Create the advertisements table
CREATE TABLE public.advertisements (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT,
  image_url TEXT,
  target_interests TEXT[],
  is_active BOOLEAN DEFAULT true NOT NULL
);

-- Add comments for clarity
COMMENT ON TABLE public.advertisements IS 'Stores internal ads for display in the app.';

-- Enable Row Level Security (RLS)
ALTER TABLE public.advertisements ENABLE ROW LEVEL SECURITY;

-- Policies for advertisements table
CREATE POLICY "Allow public read access for active ads" ON public.advertisements FOR SELECT USING (is_active = true);
CREATE POLICY "Allow admins to manage ads" ON public.advertisements FOR INSERT, UPDATE, DELETE
USING (public.get_user_role(auth.uid()) = 'admin')
WITH CHECK (public.get_user_role(auth.uid()) = 'admin');
```

### For Ad Images
1.  Go to the "Storage" section in your Supabase dashboard and create a **public** bucket named `ad-images`.

---

## Part 10: Group Chat Tables

These tables add support for multi-user group conversations.

```sql
-- Create the groups table
CREATE TABLE public.groups (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID NOT NULL REFERENCES public.profiles(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  avatar_url TEXT
);

-- Enable RLS for groups
ALTER TABLE public.groups ENABLE ROW LEVEL SECURITY;


-- Create the group_members table
CREATE TABLE public.group_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_id BIGINT NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'member', -- 'member', 'admin'
  joined_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(group_id, user_id)
);

-- Enable RLS for group_members
ALTER TABLE public.group_members ENABLE ROW LEVEL SECURITY;

-- Function to check if a user is in a group
CREATE OR REPLACE FUNCTION public.is_in_group(p_group_id BIGINT, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.group_members
    WHERE group_id = p_group_id AND user_id = p_user_id
  );
$$;

-- Policies for groups and members
CREATE POLICY "Allow members to read group info" ON public.groups FOR SELECT
USING (public.is_in_group(id, auth.uid()));

CREATE POLICY "Allow members to read member list" ON public.group_members FOR SELECT
USING (public.is_in_group(group_id, auth.uid()));

CREATE POLICY "Allow group creator to insert" ON public.groups FOR INSERT
WITH CHECK (created_by = auth.uid());

CREATE POLICY "Allow group creator to add initial members" ON public.group_members FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.groups
    WHERE id = group_id AND created_by = auth.uid()
  )
);
-- Note: More complex policies would be needed for admins to add/remove members.

-- Function to create a group and add members atomically
CREATE OR REPLACE FUNCTION public.create_group_with_members(
  p_name TEXT,
  p_member_ids UUID[]
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_group_id BIGINT;
  v_member_id UUID;
BEGIN
  -- 1. Create the new group
  INSERT INTO public.groups (name, created_by)
  VALUES (p_name, auth.uid())
  RETURNING id INTO v_group_id;

  -- 2. Add the creator as an admin member
  INSERT INTO public.group_members (group_id, user_id, role)
  VALUES (v_group_id, auth.uid(), 'admin');

  -- 3. Add the other members
  FOREACH v_member_id IN ARRAY p_member_ids
  LOOP
    -- Ensure we don't re-add the creator
    IF v_member_id <> auth.uid() THEN
      INSERT INTO public.group_members (group_id, user_id, role)
      VALUES (v_group_id, v_member_id, 'member');
    END IF;
  END LOOP;

  RETURN v_group_id;
END;
$$;
```
