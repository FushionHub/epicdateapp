# Database Schema Extensions for Advanced Features

This document contains the SQL extensions needed to implement the advanced features for the dating application.

## Part 1: AI-Powered Algorithmic Feed Tables

```sql
/*
  # User Interaction Tracking for AI Feed Algorithm

  1. New Tables
    - `user_interactions` - Tracks all user interactions for feed algorithm
    - `content_scores` - Stores computed content scores for efficient retrieval
    - `user_preferences` - Stores computed user preference vectors
  
  2. Security
    - Enable RLS on all new tables
    - Add policies for user-specific data access
*/

-- Track user interactions for feed algorithm
CREATE TABLE IF NOT EXISTS public.user_interactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content_type TEXT NOT NULL, -- 'post', 'reel', 'profile'
  content_id BIGINT NOT NULL,
  interaction_type TEXT NOT NULL, -- 'view', 'like', 'comment', 'share', 'watch_time'
  interaction_value NUMERIC DEFAULT 1, -- For watch_time, this would be seconds
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.user_interactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own interactions" ON public.user_interactions
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own interactions" ON public.user_interactions
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Store computed content scores for efficient feed generation
CREATE TABLE IF NOT EXISTS public.content_scores (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  content_type TEXT NOT NULL,
  content_id BIGINT NOT NULL,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  relevance_score NUMERIC NOT NULL DEFAULT 0,
  popularity_score NUMERIC NOT NULL DEFAULT 0,
  recency_score NUMERIC NOT NULL DEFAULT 0,
  final_score NUMERIC NOT NULL DEFAULT 0,
  computed_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(content_type, content_id, user_id)
);

ALTER TABLE public.content_scores ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own content scores" ON public.content_scores
  FOR SELECT USING (auth.uid() = user_id);

-- Store user preference vectors for personalization
CREATE TABLE IF NOT EXISTS public.user_preferences (
  user_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  interest_weights JSONB DEFAULT '{}',
  interaction_patterns JSONB DEFAULT '{}',
  last_updated TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.user_preferences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own preferences" ON public.user_preferences
  FOR SELECT USING (auth.uid() = user_id);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_interactions_user_content ON public.user_interactions(user_id, content_type, content_id);
CREATE INDEX IF NOT EXISTS idx_user_interactions_created_at ON public.user_interactions(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_content_scores_user_final ON public.content_scores(user_id, final_score DESC);
```

## Part 2: Enhanced Wallet with Monetization Features

```sql
/*
  # Enhanced Wallet System with Virtual Gifts and Boosts

  1. New Tables
    - `virtual_gifts` - Catalog of available virtual gifts
    - `user_virtual_gifts` - Track sent/received virtual gifts
    - `profile_boosts` - Track profile boost purchases and status
  
  2. Security
    - Enable RLS on all tables
    - Add appropriate policies for gift and boost systems
*/

-- Virtual gifts catalog
CREATE TABLE IF NOT EXISTS public.virtual_gifts (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  cost NUMERIC(10, 2) NOT NULL,
  currency currency_type NOT NULL DEFAULT 'NGN',
  icon_url TEXT,
  animation_url TEXT,
  rarity TEXT DEFAULT 'common', -- 'common', 'rare', 'epic', 'legendary'
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Seed virtual gifts
INSERT INTO public.virtual_gifts (name, description, cost, currency, icon_url, rarity) VALUES
('Digital Rose', 'A beautiful digital rose to show your affection', 100.00, 'NGN', '/gifts/rose.png', 'common'),
('Super Like', 'Make your like stand out from the crowd', 50.00, 'NGN', '/gifts/super-like.png', 'common'),
('Golden Heart', 'A precious golden heart for someone special', 500.00, 'NGN', '/gifts/golden-heart.png', 'rare'),
('Diamond Ring', 'The ultimate expression of love', 2000.00, 'NGN', '/gifts/diamond-ring.png', 'legendary'),
('Coffee Cup', 'Invite them for a virtual coffee date', 75.00, 'NGN', '/gifts/coffee.png', 'common'),
('Shooting Star', 'Make a wish together', 300.00, 'NGN', '/gifts/star.png', 'rare')
ON CONFLICT (name) DO NOTHING;

-- Track sent/received virtual gifts
CREATE TABLE IF NOT EXISTS public.user_virtual_gifts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  gift_id INT NOT NULL REFERENCES public.virtual_gifts(id),
  message TEXT,
  context TEXT, -- 'profile', 'live_stream', 'chat'
  context_id BIGINT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.user_virtual_gifts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read gifts they sent or received" ON public.user_virtual_gifts
  FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can send gifts" ON public.user_virtual_gifts
  FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- Profile boost system
CREATE TABLE IF NOT EXISTS public.profile_boosts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  boost_type TEXT NOT NULL DEFAULT 'visibility', -- 'visibility', 'super_boost'
  cost NUMERIC(10, 2) NOT NULL,
  currency currency_type NOT NULL DEFAULT 'NGN',
  duration_minutes INT NOT NULL DEFAULT 30,
  started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at TIMESTAMPTZ NOT NULL,
  is_active BOOLEAN DEFAULT true
);

ALTER TABLE public.profile_boosts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own boosts" ON public.profile_boosts
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create own boosts" ON public.profile_boosts
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_virtual_gifts_receiver ON public.user_virtual_gifts(receiver_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_profile_boosts_active ON public.profile_boosts(user_id, is_active, expires_at);
```

## Part 3: Gamification System

```sql
/*
  # Gamification System - Badges, Achievements, and Daily Streaks

  1. New Tables
    - `badges` - Available badges catalog
    - `user_badges` - User earned badges
    - `daily_streaks` - Track user daily login streaks
    - `achievements` - Achievement definitions
    - `user_achievements` - User earned achievements
  
  2. Security
    - Enable RLS on all tables
    - Add policies for gamification features
*/

-- Badges catalog
CREATE TABLE IF NOT EXISTS public.badges (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  description TEXT NOT NULL,
  icon_url TEXT,
  category TEXT NOT NULL, -- 'social', 'dating', 'engagement', 'premium'
  rarity TEXT DEFAULT 'common', -- 'common', 'rare', 'epic', 'legendary'
  points INT DEFAULT 10,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Seed badges
INSERT INTO public.badges (name, description, icon_url, category, rarity, points) VALUES
('Ice Breaker', 'Send your first message to a match', '/badges/ice-breaker.png', 'dating', 'common', 10),
('Social Butterfly', 'Like 50 posts in a day', '/badges/social-butterfly.png', 'social', 'common', 15),
('Content Creator', 'Upload 10 posts', '/badges/content-creator.png', 'social', 'rare', 25),
('Video Star', 'Upload 20 reels', '/badges/video-star.png', 'social', 'rare', 30),
('Generous Heart', 'Send 10 virtual gifts', '/badges/generous-heart.png', 'dating', 'rare', 20),
('Week Warrior', 'Login for 7 consecutive days', '/badges/week-warrior.png', 'engagement', 'rare', 35),
('Month Master', 'Login for 30 consecutive days', '/badges/month-master.png', 'engagement', 'epic', 100),
('Premium Pioneer', 'Subscribe to premium for the first time', '/badges/premium-pioneer.png', 'premium', 'rare', 50),
('Match Maker', 'Get 100 matches', '/badges/match-maker.png', 'dating', 'epic', 75),
('Conversation King', 'Send 1000 messages', '/badges/conversation-king.png', 'dating', 'epic', 80)
ON CONFLICT (name) DO NOTHING;

-- User earned badges
CREATE TABLE IF NOT EXISTS public.user_badges (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  badge_id INT NOT NULL REFERENCES public.badges(id),
  earned_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, badge_id)
);

ALTER TABLE public.user_badges ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own badges" ON public.user_badges
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can award badges" ON public.user_badges
  FOR INSERT WITH CHECK (true); -- This will be controlled by backend functions

-- Daily streaks tracking
CREATE TABLE IF NOT EXISTS public.daily_streaks (
  user_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  current_streak INT DEFAULT 0,
  longest_streak INT DEFAULT 0,
  last_login_date DATE,
  streak_rewards_claimed JSONB DEFAULT '{}',
  total_points INT DEFAULT 0,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.daily_streaks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own streaks" ON public.daily_streaks
  FOR SELECT USING (auth.uid() = user_id);

-- Achievements system (more complex than badges)
CREATE TABLE IF NOT EXISTS public.achievements (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  description TEXT NOT NULL,
  icon_url TEXT,
  category TEXT NOT NULL,
  criteria JSONB NOT NULL, -- Flexible criteria definition
  reward_type TEXT, -- 'wallet_credit', 'premium_days', 'badge'
  reward_value NUMERIC,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Seed achievements
INSERT INTO public.achievements (name, description, icon_url, category, criteria, reward_type, reward_value) VALUES
('First Steps', 'Complete your profile with photo and bio', '/achievements/first-steps.png', 'onboarding', 
 '{"profile_complete": true}', 'wallet_credit', 50.00),
('Social Starter', 'Make your first post and get 5 likes', '/achievements/social-starter.png', 'social',
 '{"posts_created": 1, "likes_received": 5}', 'wallet_credit', 100.00),
('Dating Dynamo', 'Get 10 matches in a week', '/achievements/dating-dynamo.png', 'dating',
 '{"matches_per_week": 10}', 'premium_days', 3),
('Engagement Expert', 'Maintain a 30-day login streak', '/achievements/engagement-expert.png', 'engagement',
 '{"login_streak": 30}', 'premium_days', 7)
ON CONFLICT (name) DO NOTHING;

-- User earned achievements
CREATE TABLE IF NOT EXISTS public.user_achievements (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  achievement_id INT NOT NULL REFERENCES public.achievements(id),
  progress JSONB DEFAULT '{}',
  completed_at TIMESTAMPTZ,
  reward_claimed BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, achievement_id)
);

ALTER TABLE public.user_achievements ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own achievements" ON public.user_achievements
  FOR SELECT USING (auth.uid() = user_id);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_badges_user ON public.user_badges(user_id, earned_at DESC);
CREATE INDEX IF NOT EXISTS idx_user_achievements_user ON public.user_achievements(user_id, completed_at DESC);
```

## Part 4: Advanced Analytics Tables

```sql
/*
  # Advanced Analytics for Admin Panel

  1. New Tables
    - `user_cohorts` - Track user cohorts for retention analysis
    - `feature_usage` - Track feature adoption and usage
    - `revenue_analytics` - Detailed revenue tracking
    - `content_moderation_logs` - AI moderation results
  
  2. Security
    - Admin-only access policies
    - Comprehensive logging for audit trails
*/

-- User cohorts for retention analysis
CREATE TABLE IF NOT EXISTS public.user_cohorts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  cohort_month DATE NOT NULL, -- First month user signed up
  registration_source TEXT, -- 'organic', 'referral', 'ads'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.user_cohorts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can read cohorts" ON public.user_cohorts
  FOR SELECT USING (public.get_user_role(auth.uid()) = 'admin');

-- Feature usage tracking
CREATE TABLE IF NOT EXISTS public.feature_usage (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  feature_name TEXT NOT NULL,
  usage_count INT DEFAULT 1,
  last_used TIMESTAMPTZ NOT NULL DEFAULT now(),
  session_id TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.feature_usage ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can read feature usage" ON public.feature_usage
  FOR SELECT USING (public.get_user_role(auth.uid()) = 'admin');

-- Revenue analytics
CREATE TABLE IF NOT EXISTS public.revenue_analytics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL,
  revenue_type TEXT NOT NULL, -- 'subscription', 'wallet_topup', 'virtual_gifts', 'boosts'
  amount NUMERIC(12, 2) NOT NULL,
  currency currency_type NOT NULL,
  user_count INT DEFAULT 1,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(date, revenue_type, currency)
);

ALTER TABLE public.revenue_analytics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can read revenue analytics" ON public.revenue_analytics
  FOR SELECT USING (public.get_user_role(auth.uid()) = 'admin');

-- Content moderation logs
CREATE TABLE IF NOT EXISTS public.content_moderation_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  content_type TEXT NOT NULL, -- 'post', 'message', 'profile', 'reel'
  content_id BIGINT NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  moderation_type TEXT NOT NULL, -- 'ai_keyword', 'ai_image', 'user_report', 'manual'
  status TEXT NOT NULL, -- 'flagged', 'approved', 'rejected', 'pending'
  confidence_score NUMERIC(3, 2), -- For AI moderation
  flags JSONB DEFAULT '{}', -- Specific flags found
  moderator_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.content_moderation_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can manage moderation logs" ON public.content_moderation_logs
  FOR ALL USING (public.get_user_role(auth.uid()) = 'admin');

-- Global app settings for dynamic configuration
CREATE TABLE IF NOT EXISTS public.app_settings (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  description TEXT,
  category TEXT DEFAULT 'general',
  is_public BOOLEAN DEFAULT false, -- Whether setting can be read by non-admins
  updated_by UUID REFERENCES public.profiles(id),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Seed app settings
INSERT INTO public.app_settings (key, value, description, category, is_public) VALUES
('wallet_bonus_percentage', '10', 'Bonus percentage for wallet top-ups', 'monetization', false),
('profile_boost_cost', '{"30min": 200, "60min": 350, "120min": 600}', 'Cost for profile boosts by duration', 'monetization', false),
('daily_streak_rewards', '{"7": 50, "14": 100, "30": 250}', 'Wallet credits for streak milestones', 'gamification', false),
('ai_moderation_enabled', 'true', 'Enable AI content moderation', 'moderation', false),
('max_daily_likes', '{"free": 50, "premium": 200, "vip": 999}', 'Daily like limits by tier', 'features', false),
('app_maintenance_mode', 'false', 'Enable maintenance mode', 'system', true)
ON CONFLICT (key) DO NOTHING;

ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can manage app settings" ON public.app_settings
  FOR ALL USING (public.get_user_role(auth.uid()) = 'admin');

CREATE POLICY "Public settings readable by all" ON public.app_settings
  FOR SELECT USING (is_public = true);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_cohorts_month ON public.user_cohorts(cohort_month);
CREATE INDEX IF NOT EXISTS idx_feature_usage_feature_date ON public.feature_usage(feature_name, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_revenue_analytics_date ON public.revenue_analytics(date DESC);
CREATE INDEX IF NOT EXISTS idx_content_moderation_status ON public.content_moderation_logs(status, created_at DESC);
```

## Part 5: Database Functions for Advanced Features

```sql
/*
  # Database Functions for Advanced Features
  
  This section contains the PostgreSQL functions needed to support
  the advanced features including AI feed algorithm, gamification,
  and enhanced monetization.
*/

-- Function to compute AI feed scores for a user
CREATE OR REPLACE FUNCTION public.compute_feed_scores(p_user_id UUID, p_content_type TEXT DEFAULT 'post')
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_interests TEXT[];
  v_interaction_weights JSONB;
  v_content_record RECORD;
BEGIN
  -- Get user interests and interaction patterns
  SELECT interests INTO v_user_interests FROM public.profiles WHERE id = p_user_id;
  
  SELECT interaction_patterns INTO v_interaction_weights 
  FROM public.user_preferences WHERE user_id = p_user_id;
  
  -- If no preferences exist, create default ones
  IF v_interaction_weights IS NULL THEN
    v_interaction_weights := '{"like": 1.0, "comment": 2.0, "share": 3.0, "view": 0.5}';
    INSERT INTO public.user_preferences (user_id, interaction_patterns)
    VALUES (p_user_id, v_interaction_weights)
    ON CONFLICT (user_id) DO UPDATE SET interaction_patterns = v_interaction_weights;
  END IF;

  -- Compute scores for posts
  IF p_content_type = 'post' THEN
    FOR v_content_record IN 
      SELECT p.id, p.user_id as author_id, p.created_at, p.interests,
             COUNT(l.id) as like_count,
             COUNT(DISTINCT c.id) as comment_count
      FROM public.posts p
      LEFT JOIN public.post_likes l ON p.id = l.post_id
      LEFT JOIN public.post_comments c ON p.id = c.post_id
      WHERE p.created_at > NOW() - INTERVAL '7 days'
      GROUP BY p.id, p.user_id, p.created_at, p.interests
    LOOP
      -- Calculate relevance score based on interests overlap
      DECLARE
        v_relevance_score NUMERIC := 0;
        v_popularity_score NUMERIC := 0;
        v_recency_score NUMERIC := 0;
        v_final_score NUMERIC := 0;
      BEGIN
        -- Relevance: interest overlap
        IF v_user_interests IS NOT NULL AND v_content_record.interests IS NOT NULL THEN
          v_relevance_score := (
            SELECT COUNT(*) * 0.2 
            FROM unnest(v_user_interests) ui 
            WHERE ui = ANY(v_content_record.interests)
          );
        END IF;
        
        -- Popularity: likes and comments
        v_popularity_score := (v_content_record.like_count * 0.1) + (v_content_record.comment_count * 0.2);
        
        -- Recency: newer content gets higher score
        v_recency_score := GREATEST(0, 1.0 - (EXTRACT(EPOCH FROM (NOW() - v_content_record.created_at)) / 86400.0));
        
        -- Final weighted score
        v_final_score := (v_relevance_score * 0.4) + (v_popularity_score * 0.3) + (v_recency_score * 0.3);
        
        -- Insert or update content score
        INSERT INTO public.content_scores (content_type, content_id, user_id, relevance_score, popularity_score, recency_score, final_score)
        VALUES (p_content_type, v_content_record.id, p_user_id, v_relevance_score, v_popularity_score, v_recency_score, v_final_score)
        ON CONFLICT (content_type, content_id, user_id) 
        DO UPDATE SET 
          relevance_score = v_relevance_score,
          popularity_score = v_popularity_score,
          recency_score = v_recency_score,
          final_score = v_final_score,
          computed_at = NOW();
      END;
    END LOOP;
  END IF;
END;
$$;

-- Function to send virtual gift
CREATE OR REPLACE FUNCTION public.send_virtual_gift(
  p_receiver_id UUID,
  p_gift_id INT,
  p_message TEXT DEFAULT NULL,
  p_context TEXT DEFAULT 'profile',
  p_context_id BIGINT DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_sender_id UUID := auth.uid();
  v_gift_cost NUMERIC;
  v_gift_currency currency_type;
  v_sender_wallet_id BIGINT;
  v_sender_balance NUMERIC;
BEGIN
  -- Prevent sending gift to self
  IF v_sender_id = p_receiver_id THEN
    RETURN json_build_object('success', false, 'error', 'Cannot send gift to yourself');
  END IF;

  -- Get gift details
  SELECT cost, currency INTO v_gift_cost, v_gift_currency
  FROM public.virtual_gifts WHERE id = p_gift_id AND is_active = true;

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Gift not found or inactive');
  END IF;

  -- Get sender's wallet
  SELECT id, balance INTO v_sender_wallet_id, v_sender_balance
  FROM public.wallets WHERE user_id = v_sender_id AND currency = v_gift_currency;

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Wallet not found for gift currency');
  END IF;

  -- Check sufficient funds
  IF v_sender_balance < v_gift_cost THEN
    RETURN json_build_object('success', false, 'error', 'Insufficient funds');
  END IF;

  -- Deduct cost from sender's wallet
  UPDATE public.wallets
  SET balance = balance - v_gift_cost
  WHERE id = v_sender_wallet_id;

  -- Record the gift
  INSERT INTO public.user_virtual_gifts (sender_id, receiver_id, gift_id, message, context, context_id)
  VALUES (v_sender_id, p_receiver_id, p_gift_id, p_message, p_context, p_context_id);

  -- Log transaction
  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES (v_sender_wallet_id, 'virtual_gift', v_gift_cost, 'Sent virtual gift: ' || p_gift_id);

  RETURN json_build_object('success', true, 'message', 'Gift sent successfully');
END;
$$;

-- Function to purchase profile boost
CREATE OR REPLACE FUNCTION public.purchase_profile_boost(
  p_duration_minutes INT DEFAULT 30,
  p_boost_type TEXT DEFAULT 'visibility'
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_boost_cost NUMERIC;
  v_wallet_id BIGINT;
  v_balance NUMERIC;
  v_expires_at TIMESTAMPTZ;
BEGIN
  -- Get boost cost from app settings
  SELECT (value->>p_duration_minutes::text)::NUMERIC INTO v_boost_cost
  FROM public.app_settings WHERE key = 'profile_boost_cost';

  IF v_boost_cost IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Invalid boost duration');
  END IF;

  -- Get user's NGN wallet
  SELECT id, balance INTO v_wallet_id, v_balance
  FROM public.wallets WHERE user_id = v_user_id AND currency = 'NGN';

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Wallet not found');
  END IF;

  -- Check sufficient funds
  IF v_balance < v_boost_cost THEN
    RETURN json_build_object('success', false, 'error', 'Insufficient funds');
  END IF;

  -- Calculate expiry time
  v_expires_at := NOW() + (p_duration_minutes || ' minutes')::INTERVAL;

  -- Deduct cost and create boost
  UPDATE public.wallets SET balance = balance - v_boost_cost WHERE id = v_wallet_id;

  INSERT INTO public.profile_boosts (user_id, boost_type, cost, currency, duration_minutes, expires_at)
  VALUES (v_user_id, p_boost_type, v_boost_cost, 'NGN', p_duration_minutes, v_expires_at);

  -- Log transaction
  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES (v_wallet_id, 'profile_boost', v_boost_cost, 'Profile boost: ' || p_duration_minutes || ' minutes');

  RETURN json_build_object('success', true, 'expires_at', v_expires_at);
END;
$$;

-- Function to update daily streak
CREATE OR REPLACE FUNCTION public.update_daily_streak(p_user_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_current_date DATE := CURRENT_DATE;
  v_streak_record RECORD;
  v_reward_amount NUMERIC := 0;
  v_new_streak INT := 0;
BEGIN
  -- Get current streak info
  SELECT * INTO v_streak_record FROM public.daily_streaks WHERE user_id = p_user_id;

  IF NOT FOUND THEN
    -- First time login
    INSERT INTO public.daily_streaks (user_id, current_streak, longest_streak, last_login_date)
    VALUES (p_user_id, 1, 1, v_current_date);
    v_new_streak := 1;
  ELSE
    -- Check if this is a consecutive day
    IF v_streak_record.last_login_date = v_current_date THEN
      -- Already logged in today
      RETURN json_build_object('success', true, 'streak', v_streak_record.current_streak, 'reward', 0);
    ELSIF v_streak_record.last_login_date = v_current_date - 1 THEN
      -- Consecutive day
      v_new_streak := v_streak_record.current_streak + 1;
      
      UPDATE public.daily_streaks
      SET current_streak = v_new_streak,
          longest_streak = GREATEST(longest_streak, v_new_streak),
          last_login_date = v_current_date,
          updated_at = NOW()
      WHERE user_id = p_user_id;
    ELSE
      -- Streak broken
      v_new_streak := 1;
      UPDATE public.daily_streaks
      SET current_streak = 1,
          last_login_date = v_current_date,
          updated_at = NOW()
      WHERE user_id = p_user_id;
    END IF;
  END IF;

  -- Check for streak rewards
  IF v_new_streak IN (7, 14, 30) THEN
    SELECT (value->>v_new_streak::text)::NUMERIC INTO v_reward_amount
    FROM public.app_settings WHERE key = 'daily_streak_rewards';
    
    IF v_reward_amount > 0 THEN
      -- Add reward to wallet
      UPDATE public.wallets
      SET balance = balance + v_reward_amount
      WHERE user_id = p_user_id AND currency = 'NGN';
      
      -- Log transaction
      INSERT INTO public.transactions (
        wallet_id, transaction_type, amount, description
      )
      SELECT id, 'streak_reward', v_reward_amount, 'Daily streak reward: ' || v_new_streak || ' days'
      FROM public.wallets WHERE user_id = p_user_id AND currency = 'NGN';
    END IF;
  END IF;

  RETURN json_build_object('success', true, 'streak', v_new_streak, 'reward', v_reward_amount);
END;
$$;

-- Function to check and award badges
CREATE OR REPLACE FUNCTION public.check_and_award_badges(p_user_id UUID, p_action TEXT, p_metadata JSONB DEFAULT '{}')
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_badge_record RECORD;
  v_user_stats RECORD;
BEGIN
  -- Get user statistics for badge checking
  SELECT 
    (SELECT COUNT(*) FROM public.messages WHERE sender_id = p_user_id) as message_count,
    (SELECT COUNT(*) FROM public.posts WHERE user_id = p_user_id) as post_count,
    (SELECT COUNT(*) FROM public.reels WHERE user_id = p_user_id) as reel_count,
    (SELECT COUNT(*) FROM public.user_virtual_gifts WHERE sender_id = p_user_id) as gifts_sent,
    (SELECT COUNT(*) FROM public.matches WHERE user1_id = p_user_id OR user2_id = p_user_id) as match_count,
    (SELECT current_streak FROM public.daily_streaks WHERE user_id = p_user_id) as login_streak
  INTO v_user_stats;

  -- Check each badge condition
  FOR v_badge_record IN SELECT * FROM public.badges WHERE is_active = true LOOP
    -- Skip if user already has this badge
    IF EXISTS (SELECT 1 FROM public.user_badges WHERE user_id = p_user_id AND badge_id = v_badge_record.id) THEN
      CONTINUE;
    END IF;

    -- Check badge conditions
    CASE v_badge_record.name
      WHEN 'Ice Breaker' THEN
        IF v_user_stats.message_count >= 1 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
      WHEN 'Content Creator' THEN
        IF v_user_stats.post_count >= 10 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
      WHEN 'Video Star' THEN
        IF v_user_stats.reel_count >= 20 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
      WHEN 'Generous Heart' THEN
        IF v_user_stats.gifts_sent >= 10 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
      WHEN 'Week Warrior' THEN
        IF v_user_stats.login_streak >= 7 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
      WHEN 'Month Master' THEN
        IF v_user_stats.login_streak >= 30 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
      WHEN 'Match Maker' THEN
        IF v_user_stats.match_count >= 100 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
      WHEN 'Conversation King' THEN
        IF v_user_stats.message_count >= 1000 THEN
          INSERT INTO public.user_badges (user_id, badge_id) VALUES (p_user_id, v_badge_record.id);
        END IF;
    END CASE;
  END LOOP;
END;
$$;

-- Function for AI content moderation
CREATE OR REPLACE FUNCTION public.moderate_content(
  p_content_type TEXT,
  p_content_id BIGINT,
  p_content_text TEXT,
  p_user_id UUID
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_flagged_keywords TEXT[] := ARRAY['spam', 'scam', 'fake', 'inappropriate', 'offensive'];
  v_flags JSONB := '{}';
  v_confidence NUMERIC := 0;
  v_status TEXT := 'approved';
  v_keyword TEXT;
BEGIN
  -- Simple keyword-based moderation
  FOREACH v_keyword IN ARRAY v_flagged_keywords LOOP
    IF LOWER(p_content_text) LIKE '%' || v_keyword || '%' THEN
      v_flags := v_flags || jsonb_build_object(v_keyword, true);
      v_confidence := v_confidence + 0.2;
    END IF;
  END LOOP;

  -- Determine status based on confidence
  IF v_confidence >= 0.4 THEN
    v_status := 'flagged';
  ELSIF v_confidence >= 0.2 THEN
    v_status := 'pending';
  END IF;

  -- Log moderation result
  INSERT INTO public.content_moderation_logs (
    content_type, content_id, user_id, moderation_type, status, confidence_score, flags
  ) VALUES (
    p_content_type, p_content_id, p_user_id, 'ai_keyword', v_status, v_confidence, v_flags
  );

  RETURN json_build_object(
    'status', v_status,
    'confidence', v_confidence,
    'flags', v_flags
  );
END;
$$;
```