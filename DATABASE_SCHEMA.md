# Supabase Database Schema

This file contains the necessary SQL to set up the database tables for the dating application in your Supabase project. The schema has been reorganized and corrected for logical consistency and to ensure successful execution.

## Instructions

1.  Navigate to your Supabase project dashboard.
2.  In the left sidebar, click on the "SQL Editor" icon.
3.  Click "New query".
4.  Copy the SQL code below and paste it into the SQL editor.
5.  Click "Run" to execute the query and create the tables and functions.

---

## Part 1: Core Types & Helper Functions

This section defines custom types and helper functions that are used across multiple tables. They are defined first to prevent dependency errors.

```sql
-- Create a new ENUM type for currency, used in wallets and listings.
CREATE TYPE public.currency_type AS ENUM ('USD', 'NGN', 'EUR', 'GBP');

-- Create a helper function to get a user's role, used in various RLS policies.
CREATE OR REPLACE FUNCTION public.get_user_role(p_user_id UUID)
RETURNS TEXT
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT role FROM public.profiles WHERE id = p_user_id;
$$;
```

---

## Part 2: User & Profile Tables

This section sets up the core tables for users and their profiles.

```sql
-- Create the ringtones table first as it's a dependency for profiles.
CREATE TABLE IF NOT EXISTS public.ringtones (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  url TEXT NOT NULL
);

-- Seed with some default ringtones
INSERT INTO public.ringtones (name, url) VALUES
('Classic Phone', '/ringtones/classic.mp3'),
('Digital Alarm', '/ringtones/digital.mp3')
ON CONFLICT (name) DO NOTHING;


-- Create the profiles table, which links to auth.users
CREATE TABLE public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  name TEXT,
  age INT,
  bio TEXT,
  photos TEXT[],
  interests TEXT[],
  is_verified BOOLEAN DEFAULT FALSE,
  subscription_tier TEXT DEFAULT 'free' NOT NULL,
  ringtone_id INT REFERENCES public.ringtones(id) DEFAULT 1,
  last_seen TIMESTAMPTZ DEFAULT now() NOT NULL,
  profile_score INT DEFAULT 0 NOT NULL,
  kyc_status TEXT DEFAULT 'not_started' NOT NULL, -- ('not_started', 'pending', 'approved', 'rejected')
  role TEXT DEFAULT 'user' NOT NULL,
  phone_number TEXT UNIQUE
);

COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';

-- Enable Row Level Security (RLS) for the profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
CREATE POLICY "Allow public read access" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Allow individual insert" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow individual update" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow admins to update any profile" ON public.profiles FOR UPDATE USING (public.get_user_role(auth.uid()) = 'admin');

-- Note: The insecure 'users_with_details' view has been removed.
-- Admin queries should be done directly against tables using a service role client.
```

---

## Part 3: Dating & Matchmaking Tables & Functions

These tables handle the core dating-feature logic.

```sql
-- Create the likes table
CREATE TABLE public.likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  liker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  liked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(liker_id, liked_id)
);

ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual insert for likes" ON public.likes FOR INSERT WITH CHECK (auth.uid() = liker_id);
CREATE POLICY "Allow individual read for likes" ON public.likes FOR SELECT USING (auth.uid() = liker_id OR auth.uid() = liked_id);


-- Create the matches table
CREATE TABLE public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user1_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  user2_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(user1_id, user2_id)
);

ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual read for matches" ON public.matches FOR SELECT USING (auth.uid() = user1_id OR auth.uid() = user2_id);


-- View to simplify fetching match data with the other user's profile
CREATE OR REPLACE VIEW public.v_matches_with_users AS
SELECT
  m.id AS match_id,
  m.created_at AS matched_at,
  m.user1_id,
  p1.name AS user1_name,
  p1.photos AS user1_photos,
  m.user2_id,
  p2.name AS user2_name,
  p2.photos AS user2_photos
FROM
  public.matches m
  JOIN public.profiles p1 ON m.user1_id = p1.id
  JOIN public.profiles p2 ON m.user2_id = p2.id;


-- Function to create a like and check for a match
CREATE OR REPLACE FUNCTION public.create_like_and_match(p_liked_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_liker_id UUID := auth.uid();
  v_match_exists BOOLEAN;
  v_new_match_id BIGINT;
  v_user1 UUID := LEAST(v_liker_id, p_liked_id);
  v_user2 UUID := GREATEST(v_liker_id, p_liked_id);
BEGIN
  -- Prevent user from liking themselves
  IF v_liker_id = p_liked_id THEN
      RETURN json_build_object('matched', false, 'error', 'Cannot like yourself.');
  END IF;

  -- Insert the new like, handling potential conflicts
  INSERT INTO public.likes (liker_id, liked_id)
  VALUES (v_liker_id, p_liked_id)
  ON CONFLICT (liker_id, liked_id) DO NOTHING;

  -- Check if the other user has already liked the current user
  SELECT EXISTS (
    SELECT 1 FROM public.likes WHERE liker_id = p_liked_id AND liked_id = v_liker_id
  ) INTO v_match_exists;

  -- If a match exists, create a new match entry
  IF v_match_exists THEN
    -- Insert with consistent user order to prevent duplicates like (A,B) and (B,A)
    INSERT INTO public.matches (user1_id, user2_id)
    VALUES (v_user1, v_user2)
    ON CONFLICT (user1_id, user2_id) DO NOTHING
    RETURNING id INTO v_new_match_id;

    -- If the insert was new, v_new_match_id will have a value.
    -- If the match already existed due to a race condition, the insert would be ignored.
    -- In that case, we must fetch the existing match_id to return it.
    IF v_new_match_id IS NULL THEN
        SELECT id INTO v_new_match_id FROM public.matches WHERE user1_id = v_user1 AND user2_id = v_user2;
    END IF;

    RETURN json_build_object('matched', true, 'match_id', v_new_match_id);
  ELSE
    RETURN json_build_object('matched', false);
  END IF;
END;
$$;
```

---

## Part 4: Group Chat Tables & Functions

This section handles multi-user group conversations.

```sql
-- Create the groups table
CREATE TABLE public.groups (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  avatar_url TEXT
);

ALTER TABLE public.groups ENABLE ROW LEVEL SECURITY;


-- Create the group_members table
CREATE TABLE public.group_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_id BIGINT NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'member', -- 'member', 'admin'
  joined_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(group_id, user_id)
);

ALTER TABLE public.group_members ENABLE ROW LEVEL SECURITY;


-- Function to check if a user is in a group (dependency for messages RLS)
CREATE OR REPLACE FUNCTION public.is_in_group(p_group_id BIGINT, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.group_members
    WHERE group_id = p_group_id AND user_id = p_user_id
  );
$$;

-- Policies for groups and members
CREATE POLICY "Allow members to read group info" ON public.groups FOR SELECT
USING (public.is_in_group(id, auth.uid()));

CREATE POLICY "Allow members to read member list" ON public.group_members FOR SELECT
USING (public.is_in_group(group_id, auth.uid()));

CREATE POLICY "Allow group creator to insert" ON public.groups FOR INSERT
WITH CHECK (created_by = auth.uid());

CREATE POLICY "Allow group creator to add initial members" ON public.group_members FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.groups
    WHERE id = group_id AND created_by = auth.uid()
  )
);

-- Function to create a group and add members atomically
CREATE OR REPLACE FUNCTION public.create_group_with_members(
  p_name TEXT,
  p_member_ids UUID[]
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_group_id BIGINT;
  v_member_id UUID;
BEGIN
  -- 1. Create the new group
  INSERT INTO public.groups (name, created_by)
  VALUES (p_name, auth.uid())
  RETURNING id INTO v_group_id;

  -- 2. Add the creator as an admin member
  INSERT INTO public.group_members (group_id, user_id, role)
  VALUES (v_group_id, auth.uid(), 'admin');

  -- 3. Add the other members
  FOREACH v_member_id IN ARRAY p_member_ids
  LOOP
    -- Ensure we don't re-add the creator
    IF v_member_id <> auth.uid() THEN
      INSERT INTO public.group_members (group_id, user_id, role)
      VALUES (v_group_id, v_member_id, 'member');
    END IF;
  END LOOP;

  RETURN v_group_id;
END;
$$;
```

---

## Part 5: Messaging & Chat Tables

This section defines the core messaging table for both private and group chats.

```sql
-- Function to check if a user is part of a match (dependency for messages RLS)
CREATE OR REPLACE FUNCTION public.is_in_match(p_match_id BIGINT, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.matches
    WHERE id = p_match_id AND (user1_id = p_user_id OR user2_id = p_user_id)
  );
$$;

-- Create the messages table
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,

  -- Conversation link
  match_id BIGINT REFERENCES public.matches(id) ON DELETE CASCADE,
  group_id BIGINT REFERENCES public.groups(id) ON DELETE CASCADE,
  marketplace_conversation_id BIGINT REFERENCES public.marketplace_conversations(id) ON DELETE CASCADE,

  -- Message content
  message_type TEXT NOT NULL DEFAULT 'text', -- 'text', 'image', 'video', 'audio'
  text_content TEXT,
  media_url TEXT,
  is_edited BOOLEAN DEFAULT false NOT NULL,
  is_view_once BOOLEAN DEFAULT false NOT NULL,
  is_viewed BOOLEAN DEFAULT false NOT NULL,

  -- Ensure exactly one conversation link is NOT NULL
  CONSTRAINT conversation_check CHECK (
    (CASE WHEN match_id IS NOT NULL THEN 1 ELSE 0 END) +
    (CASE WHEN group_id IS NOT NULL THEN 1 ELSE 0 END) +
    (CASE WHEN marketplace_conversation_id IS NOT NULL THEN 1 ELSE 0 END)
    = 1
  )
);

-- Enable RLS for messages
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Policies for messages table
CREATE POLICY "Allow access to members of the conversation" ON public.messages FOR ALL
USING (
  (match_id IS NOT NULL AND public.is_in_match(match_id, auth.uid())) OR
  (group_id IS NOT NULL AND public.is_in_group(group_id, auth.uid())) OR
  (marketplace_conversation_id IS NOT NULL AND public.is_in_marketplace_conversation(marketplace_conversation_id, auth.uid()))
)
WITH CHECK (
  ( -- Check for insert/update
    (match_id IS NOT NULL AND public.is_in_match(match_id, auth.uid())) OR
    (group_id IS NOT NULL AND public.is_in_group(group_id, auth.uid())) OR
    (marketplace_conversation_id IS NOT NULL AND public.is_in_marketplace_conversation(marketplace_conversation_id, auth.uid()))
  ) AND
  sender_id = auth.uid()
);
```

---

## Part 6: Social Features (Posts, Followers, etc.)

This section includes tables for timelines, following, blocking, and reporting.

```sql
-- Create the posts table
CREATE TABLE public.posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  text_content TEXT,
  image_url TEXT,
  is_boosted BOOLEAN DEFAULT false NOT NULL,
  boost_expires_at TIMESTAMPTZ
);

ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access for posts" ON public.posts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for posts" ON public.posts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual update for posts" ON public.posts FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual delete for posts" ON public.posts FOR DELETE USING (auth.uid() = user_id);


-- Create the followers table
CREATE TABLE public.followers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  follower_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  following_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(follower_id, following_id)
);

ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read on followers" ON public.followers FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for followers" ON public.followers FOR INSERT WITH CHECK (auth.uid() = follower_id);
CREATE POLICY "Allow individual delete for followers" ON public.followers FOR DELETE USING (auth.uid() = follower_id);


-- Create the blocked_users table
CREATE TABLE public.blocked_users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  blocker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  blocked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(blocker_id, blocked_id)
);

ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual access for blocked users" ON public.blocked_users FOR ALL
USING (auth.uid() = blocker_id)
WITH CHECK (auth.uid() = blocker_id);


-- Create the reports table
CREATE TABLE public.reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  reporter_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reported_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reason TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'resolved', 'dismissed'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual insert for reports" ON public.reports FOR INSERT
WITH CHECK (auth.uid() = reporter_id);
-- Note: An admin role would be needed to read/update reports. This is a basic setup.
```

---

## Part 7: Monetization & Wallet Tables

This section handles wallets, transactions, and gifts.

```sql
-- Create the wallets table
CREATE TABLE public.wallets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL UNIQUE REFERENCES public.profiles(id) ON DELETE CASCADE,
  currency currency_type NOT NULL,
  balance NUMERIC(12, 2) NOT NULL DEFAULT 0.00,
  UNIQUE(user_id, currency)
);

ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual read access for wallets" ON public.wallets FOR SELECT USING (auth.uid() = user_id);


-- Create the transactions table
CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_id BIGINT NOT NULL REFERENCES public.wallets(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  transaction_type TEXT NOT NULL, -- e.g., 'deposit', 'gift_sent', 'subscription_fee'
  amount NUMERIC(12, 2) NOT NULL,
  description TEXT
);

ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual read access for transactions" ON public.transactions FOR SELECT USING (
  EXISTS (SELECT 1 FROM wallets WHERE id = wallet_id AND user_id = auth.uid())
);


-- Trigger function to create wallets for a new user automatically
CREATE OR REPLACE FUNCTION public.create_user_wallets()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.wallets (user_id, currency)
  VALUES
    (NEW.id, 'NGN'),
    (NEW.id, 'USD'),
    (NEW.id, 'EUR'),
    (NEW.id, 'GBP');
  RETURN NEW;
END;
$$;

-- Trigger to call the function when a new profile is created
CREATE TRIGGER on_profile_created_wallets
  AFTER INSERT ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.create_user_wallets();


-- Create gift_types table
CREATE TABLE public.gift_types (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  cost NUMERIC(10, 2) NOT NULL,
  currency currency_type NOT NULL DEFAULT 'NGN',
  icon_url TEXT
);

-- Seed some default gifts
INSERT INTO public.gift_types (name, cost, currency, icon_url) VALUES
('Rose', 500.00, 'NGN', '/gifts/rose.png'),
('Diamond', 5000.00, 'NGN', '/gifts/diamond.png'),
('Teddy Bear', 2500.00, 'NGN', '/gifts/bear.png')
ON CONFLICT (name) DO NOTHING;

-- Create user_gifts table
CREATE TABLE public.user_gifts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  gift_type_id INT NOT NULL REFERENCES public.gift_types(id)
);

ALTER TABLE public.user_gifts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read on gifts" ON public.user_gifts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for gifts" ON public.user_gifts FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- Function to handle the transaction for boosting a post
CREATE OR REPLACE FUNCTION public.boost_post_transaction(
  p_post_id BIGINT,
  p_user_id UUID,
  p_wallet_id BIGINT,
  p_boost_cost NUMERIC,
  p_boost_expires_at TIMESTAMPTZ
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- 1. Deduct the cost from the user's wallet
  UPDATE public.wallets
  SET balance = balance - p_boost_cost
  WHERE id = p_wallet_id AND user_id = p_user_id;

  -- 2. Log the transaction
  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES (p_wallet_id, 'post_boost', p_boost_cost, 'Boosted post ID: ' || p_post_id);

  -- 3. Update the post to mark it as boosted
  UPDATE public.posts
  SET
    is_boosted = true,
    boost_expires_at = p_boost_expires_at
  WHERE id = p_post_id AND user_id = p_user_id;
END;
$$;


-- Function to send a virtual gift from one user to another
CREATE OR REPLACE FUNCTION public.send_gift(p_receiver_id UUID, p_gift_type_id INT)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_sender_id UUID := auth.uid();
  v_gift_cost NUMERIC;
  v_gift_currency currency_type;
  v_sender_wallet_id BIGINT;
  v_sender_balance NUMERIC;
BEGIN
  -- 1. Get gift details
  SELECT cost, currency INTO v_gift_cost, v_gift_currency
  FROM public.gift_types WHERE id = p_gift_type_id;

  IF NOT FOUND THEN
    RETURN 'Error: Gift type not found.';
  END IF;

  -- 2. Get sender's wallet and balance
  SELECT id, balance INTO v_sender_wallet_id, v_sender_balance
  FROM public.wallets WHERE user_id = v_sender_id AND currency = v_gift_currency;

  IF NOT FOUND THEN
    RETURN 'Error: Sender wallet not found for the gift currency.';
  END IF;

  -- 3. Check for sufficient funds
  IF v_sender_balance < v_gift_cost THEN
    RETURN 'Error: Insufficient funds.';
  END IF;

  -- 4. Deduct cost from sender's wallet
  UPDATE public.wallets
  SET balance = balance - v_gift_cost
  WHERE id = v_sender_wallet_id;

  -- 5. Create the user_gifts entry
  INSERT INTO public.user_gifts (sender_id, receiver_id, gift_type_id)
  VALUES (v_sender_id, p_receiver_id, p_gift_type_id);

  -- 6. Create a transaction record
  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES (v_sender_wallet_id, 'gift_sent', v_gift_cost, 'Sent gift to user ' || p_receiver_id);

  RETURN 'Success: Gift sent successfully.';
END;
$$;

-- Function to transfer funds from one user's wallet to another's
CREATE OR REPLACE FUNCTION public.transfer_funds(p_receiver_id UUID, p_amount NUMERIC, p_currency currency_type)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_sender_id UUID := auth.uid();
  v_sender_wallet_id BIGINT;
  v_receiver_wallet_id BIGINT;
  v_sender_balance NUMERIC;
BEGIN
  -- Ensure amount is positive
  IF p_amount <= 0 THEN
    RETURN 'Error: Transfer amount must be positive.';
  END IF;

  -- Get sender's wallet and balance
  SELECT id, balance INTO v_sender_wallet_id, v_sender_balance
  FROM public.wallets WHERE user_id = v_sender_id AND currency = p_currency;

  IF v_sender_wallet_id IS NULL THEN
    RETURN 'Error: Sender wallet not found.';
  END IF;

  -- Check for sufficient funds
  IF v_sender_balance < p_amount THEN
    RETURN 'Error: Insufficient funds.';
  END IF;

  -- Get receiver's wallet
  SELECT id INTO v_receiver_wallet_id
  FROM public.wallets WHERE user_id = p_receiver_id AND currency = p_currency;

  IF v_receiver_wallet_id IS NULL THEN
    RETURN 'Error: Receiver does not have a wallet for the specified currency.';
  END IF;

  -- Perform the transfer
  -- 1. Deduct from sender
  UPDATE public.wallets SET balance = balance - p_amount WHERE id = v_sender_wallet_id;
  -- 2. Add to receiver
  UPDATE public.wallets SET balance = balance + p_amount WHERE id = v_receiver_wallet_id;

  -- 3. Log transactions for both parties
  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES (v_sender_wallet_id, 'transfer_sent', p_amount, 'Sent ' || p_amount || ' ' || p_currency || ' to user ' || p_receiver_id);

  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES (v_receiver_wallet_id, 'transfer_received', p_amount, 'Received ' || p_amount || ' ' || p_currency || ' from user ' || v_sender_id);

  RETURN 'Success: Transfer completed successfully.';
END;
$$;
```

---

## Part 8: Marketplace Tables & Functions

This section handles the marketplace listings and seller communication.

```sql
-- Create the listings table for the marketplace
CREATE TABLE public.listings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  price NUMERIC(12, 2) NOT NULL,
  currency currency_type NOT NULL,
  category TEXT,
  image_urls TEXT[],
  location TEXT,
  is_sold BOOLEAN DEFAULT false NOT NULL
);

ALTER TABLE public.listings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access to non-sold listings" ON public.listings FOR SELECT USING (is_sold = false);
CREATE POLICY "Allow admins to read all listings" ON public.listings FOR SELECT USING (public.get_user_role(auth.uid()) = 'admin');
CREATE POLICY "Allow users to manage their own listings" ON public.listings FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);


-- Create a dedicated table for marketplace conversations
CREATE TABLE public.marketplace_conversations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  listing_id BIGINT REFERENCES public.listings(id) ON DELETE SET NULL,
  buyer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  seller_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(listing_id, buyer_id) -- A buyer can only start one conversation per listing
);

ALTER TABLE public.marketplace_conversations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow members to access their conversations" ON public.marketplace_conversations
FOR SELECT USING (auth.uid() = buyer_id OR auth.uid() = seller_id);


-- Helper function to check if a user is part of a marketplace conversation
CREATE OR REPLACE FUNCTION public.is_in_marketplace_conversation(p_conversation_id BIGINT, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.marketplace_conversations
    WHERE id = p_conversation_id AND (buyer_id = p_user_id OR seller_id = p_user_id)
  );
$$;


-- This function now creates a dedicated conversation record instead of a generic match.
CREATE OR REPLACE FUNCTION public.create_conversation_for_listing(p_listing_id BIGINT)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_buyer_id UUID := auth.uid();
  v_seller_id UUID;
  v_conversation_id BIGINT;
BEGIN
  -- Get the seller from the listing
  SELECT user_id INTO v_seller_id FROM public.listings WHERE id = p_listing_id;

  -- Prevent user from starting a conversation with themselves
  IF v_buyer_id = v_seller_id THEN
    RAISE EXCEPTION 'Cannot start a conversation with yourself over your own listing.';
  END IF;

  -- Check if a conversation already exists for this buyer and listing
  SELECT id INTO v_conversation_id
  FROM public.marketplace_conversations
  WHERE listing_id = p_listing_id AND buyer_id = v_buyer_id;

  -- If no conversation exists, create one
  IF v_conversation_id IS NULL THEN
    INSERT INTO public.marketplace_conversations (listing_id, buyer_id, seller_id)
    VALUES (p_listing_id, v_buyer_id, v_seller_id)
    RETURNING id INTO v_conversation_id;
  END IF;

  RETURN v_conversation_id;
END;
$$;
```

---

## Part 9: KYC (Know Your Customer) Tables

```sql
-- Create the kyc_documents table
CREATE TABLE public.kyc_documents (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  document_type TEXT NOT NULL, -- e.g., 'passport', 'nin', 'bvn'
  document_url TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  reviewed_at TIMESTAMPTZ
);

ALTER TABLE public.kyc_documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual to manage their own KYC docs" ON public.kyc_documents FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
```

---

## Part 10: Admin & Site Settings Tables

```sql
-- Create the site_settings table
CREATE TABLE public.site_settings (
  key TEXT PRIMARY KEY,
  value TEXT
);

ALTER TABLE public.site_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access to site settings" ON public.site_settings FOR SELECT USING (true);
CREATE POLICY "Allow admins to manage site settings" ON public.site_settings FOR ALL
USING (public.get_user_role(auth.uid()) = 'admin')
WITH CHECK (public.get_user_role(auth.uid()) = 'admin');

-- Seed with default values
INSERT INTO public.site_settings (key, value) VALUES
  ('appName', 'EuroMeet Online'),
  ('seoDescription', 'A feature-rich Super App that combines the best of social media and dating applications.'),
  ('seoKeywords', 'dating, social media, chat, video call, friends'),
  ('logoUrl', '/logo.png')
ON CONFLICT (key) DO NOTHING;


-- Create the advertisements table
CREATE TABLE public.advertisements (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT,
  image_url TEXT,
  target_interests TEXT[],
  is_active BOOLEAN DEFAULT true NOT NULL
);

COMMENT ON TABLE public.advertisements IS 'Stores internal ads for display in the app.';
ALTER TABLE public.advertisements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access for active ads" ON public.advertisements FOR SELECT USING (is_active = true);
CREATE POLICY "Allow admins to manage ads" ON public.advertisements FOR ALL
USING (public.get_user_role(auth.uid()) = 'admin')
WITH CHECK (public.get_user_role(auth.uid()) = 'admin');
```

---

## Part 11: Supabase Storage Policies

These policies are required for the application's file upload features.

```sql
-- For Post Images (public bucket: 'post-images')
-- For Chat Media (public bucket: 'chat-media')
-- For Ringtones (public bucket: 'ringtones')
-- For Ad Images (public bucket: 'ad-images')
-- For Listing Images (public bucket: 'listing-images')
-- No specific policies needed for public buckets beyond the bucket-level public access setting.


-- For KYC Documents (private bucket: 'kyc-documents')
CREATE POLICY "Allow authenticated KYC uploads" ON storage.objects FOR INSERT TO authenticated
WITH CHECK (bucket_id = 'kyc-documents' AND (storage.foldername(name))[1] = auth.uid()::text);

CREATE POLICY "Allow individual read on KYC docs" ON storage.objects FOR SELECT
USING (bucket_id = 'kyc-documents' AND (storage.foldername(name))[1] = auth.uid()::text);
```
