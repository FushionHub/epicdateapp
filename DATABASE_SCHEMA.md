# Supabase Database Schema

This file contains the necessary SQL to set up the database tables for the dating application in your Supabase project.

## Instructions

1.  Navigate to your Supabase project dashboard.
2.  In the left sidebar, click on the "SQL Editor" icon.
3.  Click "New query".
4.  Copy the SQL code below and paste it into the SQL editor.
5.  Click "Run" to execute the query and create the tables and functions.

---

## Part 1: Profiles Table

This table stores the public profile information for each user.

```sql
-- Create the profiles table
CREATE TABLE public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  name TEXT,
  age INT,
  bio TEXT,
  photos TEXT[],
  interests TEXT[],
  is_verified BOOLEAN DEFAULT FALSE,
  subscription_tier TEXT DEFAULT 'free' NOT NULL -- Added for Monetization
);

-- Add comments for clarity
COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';

-- Enable Row Level Security (RLS) for the profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
CREATE POLICY "Allow public read access" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Allow individual insert" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow individual update" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
```

---

## Part 2: Likes and Matches Tables

These tables handle the matchmaking logic.

```sql
-- Create the likes table
CREATE TABLE public.likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  liker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  liked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(liker_id, liked_id)
);

-- Enable RLS for likes
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

-- Policies for likes table
CREATE POLICY "Allow individual insert for likes" ON public.likes FOR INSERT WITH CHECK (auth.uid() = liker_id);
CREATE POLICY "Allow individual read for likes" ON public.likes FOR SELECT USING (auth.uid() = liker_id OR auth.uid() = liked_id);


-- Create the matches table
CREATE TABLE public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user1_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  user2_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(user1_id, user2_id)
);

-- Enable RLS for matches
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;

-- Policies for matches table
CREATE POLICY "Allow individual read for matches" ON public.matches FOR SELECT USING (auth.uid() = user1_id OR auth.uid() = user2_id);
```

---

## Part 3: Database Function for Matching

This function handles the logic of creating a `like` and checking for a `match`.

```sql
-- Function to create a like and check for a match
CREATE OR REPLACE FUNCTION public.create_like_and_match(p_liked_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_liker_id UUID := auth.uid();
  v_match_exists BOOLEAN;
  v_new_match_id BIGINT;
BEGIN
  -- Insert the new like
  INSERT INTO public.likes (liker_id, liked_id)
  VALUES (v_liker_id, p_liked_id);

  -- Check if the other user has already liked the current user
  SELECT EXISTS (
    SELECT 1 FROM public.likes WHERE liker_id = p_liked_id AND liked_id = v_liker_id
  ) INTO v_match_exists;

  -- If a match exists, create a new match entry
  IF v_match_exists THEN
    INSERT INTO public.matches (user1_id, user2_id)
    VALUES (v_liker_id, p_liked_id)
    ON CONFLICT (user1_id, user2_id) DO NOTHING
    RETURNING id INTO v_new_match_id;

    RETURN json_build_object('matched', true, 'match_id', v_new_match_id);
  ELSE
    RETURN json_build_object('matched', false);
  END IF;
END;
$$;
```

---

## Part 4: Posts Table for Timeline/Feed

This table stores posts made by users.

```sql
-- Create the posts table
CREATE TABLE public.posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  text_content TEXT,
  image_url TEXT
);

-- Enable RLS for posts
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

-- Policies for posts table
CREATE POLICY "Allow public read access for posts" ON public.posts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for posts" ON public.posts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual update for posts" ON public.posts FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual delete for posts" ON public.posts FOR DELETE USING (auth.uid() = user_id);
```

---

## Part 5: Messages Table for Chat

This table stores all chat messages between matched users.

```sql
-- Create the messages table
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  match_id BIGINT NOT NULL REFERENCES public.matches(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  message_type TEXT NOT NULL DEFAULT 'text', -- 'text', 'image', 'video', 'audio'
  text_content TEXT,
  media_url TEXT
);

-- Enable RLS for messages
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Function to check if a user is part of a match
CREATE OR REPLACE FUNCTION public.is_in_match(p_match_id BIGINT, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.matches
    WHERE id = p_match_id AND (user1_id = p_user_id OR user2_id = p_user_id)
  );
$$;

-- Policies for messages table
CREATE POLICY "Allow read access to members of a match" ON public.messages FOR SELECT USING (is_in_match(match_id, auth.uid()));
CREATE POLICY "Allow insert access to members of a match" ON public.messages FOR INSERT WITH CHECK (is_in_match(match_id, auth.uid()) AND sender_id = auth.uid());
```

---

## Part 6: Monetization Tables & Functions

These tables provide the foundation for the wallet and subscription system.

```sql
-- Create the wallets table
CREATE TABLE public.wallets (
  id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  balance NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Enable RLS for wallets
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;

-- Policies for wallets
CREATE POLICY "Allow individual read access for wallets" ON public.wallets FOR SELECT USING (auth.uid() = id);


-- Create the transactions table
CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_id UUID NOT NULL REFERENCES public.wallets(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  transaction_type TEXT NOT NULL, -- e.g., 'deposit', 'gift_sent', 'subscription_fee'
  amount NUMERIC(10, 2) NOT NULL,
  description TEXT
);

-- Enable RLS for transactions
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- Policies for transactions
CREATE POLICY "Allow individual read access for transactions" ON public.transactions FOR SELECT USING (auth.uid() = wallet_id);


-- Function to create a wallet for a new user automatically
CREATE OR REPLACE FUNCTION public.create_user_wallet()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.wallets (id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$$;

-- Trigger to call the function when a new profile is created
CREATE TRIGGER on_profile_created
  AFTER INSERT ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.create_user_wallet();

-- Function to handle deposits atomically
CREATE OR REPLACE FUNCTION public.deposit_into_wallet(p_user_id UUID, p_amount NUMERIC, p_description TEXT)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  -- Update the wallet balance
  UPDATE public.wallets
  SET balance = balance + p_amount
  WHERE id = p_user_id;

  -- Insert a record of the transaction
  INSERT INTO public.transactions(wallet_id, transaction_type, amount, description)
  VALUES (p_user_id, 'deposit', p_amount, p_description);
END;
$$;

-- Create gift_types table
CREATE TABLE public.gift_types (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  cost NUMERIC(10, 2) NOT NULL,
  icon_url TEXT
);

-- Seed some default gifts
INSERT INTO public.gift_types (name, cost, icon_url) VALUES
('Rose', 1.00, '/gifts/rose.png'),
('Diamond', 10.00, '/gifts/diamond.png'),
('Teddy Bear', 5.00, '/gifts/bear.png');

-- Create user_gifts table
CREATE TABLE public.user_gifts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  gift_type_id INT NOT NULL REFERENCES public.gift_types(id)
);

-- Enable RLS
ALTER TABLE public.user_gifts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read on gifts" ON public.user_gifts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for gifts" ON public.user_gifts FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- Function to send a gift
CREATE OR REPLACE FUNCTION public.send_gift(p_receiver_id UUID, p_gift_type_id INT)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_sender_id UUID := auth.uid();
  v_gift_cost NUMERIC;
  v_sender_balance NUMERIC;
BEGIN
  -- Get gift cost
  SELECT cost INTO v_gift_cost FROM public.gift_types WHERE id = p_gift_type_id;

  -- Get sender's balance
  SELECT balance INTO v_sender_balance FROM public.wallets WHERE id = v_sender_id;

  -- Check if sender has enough balance
  IF v_sender_balance < v_gift_cost THEN
    RETURN 'Error: Insufficient balance.';
  END IF;

  -- Deduct cost from sender's wallet
  UPDATE public.wallets SET balance = balance - v_gift_cost WHERE id = v_sender_id;
  -- Record the transaction for the sender
  INSERT INTO public.transactions(wallet_id, transaction_type, amount, description)
  VALUES (v_sender_id, 'gift_sent', -v_gift_cost, 'Sent gift to user ' || p_receiver_id);

  -- Record the gift
  INSERT INTO public.user_gifts(sender_id, receiver_id, gift_type_id)
  VALUES (v_sender_id, p_receiver_id);

  RETURN 'Success: Gift sent!';
END;
$$;
```

---

## Part 7: Core Social Features Tables

```sql
-- Create the followers table
CREATE TABLE public.followers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  follower_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  following_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(follower_id, following_id)
);

-- Enable RLS
ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow public read on followers" ON public.followers FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for followers" ON public.followers FOR INSERT WITH CHECK (auth.uid() = follower_id);
CREATE POLICY "Allow individual delete for followers" ON public.followers FOR DELETE USING (auth.uid() = follower_id);


-- Create the blocked_users table
CREATE TABLE public.blocked_users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  blocker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  blocked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(blocker_id, blocked_id)
);

-- Enable RLS
ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual access for blocked users" ON public.blocked_users FOR ALL
USING (auth.uid() = blocker_id)
WITH CHECK (auth.uid() = blocker_id);

-- Create the reports table
CREATE TABLE public.reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  reporter_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reported_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reason TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'resolved', 'dismissed'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual insert for reports" ON public.reports FOR INSERT
WITH CHECK (auth.uid() = reporter_id);
-- Note: An admin role would be needed to read/update reports. This is a basic setup.
```

---

## Part 8: Notifications

```sql
-- Create the fcm_tokens table
CREATE TABLE public.fcm_tokens (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  token TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, token)
);

-- Enable RLS
ALTER TABLE public.fcm_tokens ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual access for fcm_tokens" ON public.fcm_tokens FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Function to call the send-fcm-notification Edge Function
CREATE OR REPLACE FUNCTION public.trigger_fcm_notification()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  recipient_id UUID;
  sender_name TEXT;
  message_body TEXT;
BEGIN
  -- Determine the recipient of the notification
  SELECT user1_id, user2_id INTO recipient_id
  FROM public.matches
  WHERE id = NEW.match_id;

  IF NEW.sender_id = recipient_id THEN
    SELECT user2_id INTO recipient_id FROM public.matches WHERE id = NEW.match_id;
  END IF;

  -- Get sender's name
  SELECT name INTO sender_name FROM public.profiles WHERE id = NEW.sender_id;

  -- Truncate message for notification
  message_body := substr(NEW.text_content, 1, 100);

  -- Perform the HTTP request to the Edge Function
  -- Note: You need to enable the `http` extension in Supabase: `create extension http;`
  PERFORM http_post(
    'https://<YOUR_PROJECT_REF>.supabase.co/functions/v1/send-fcm-notification',
    jsonb_build_object(
      'recipientId', recipient_id,
      'title', 'New Message from ' || sender_name,
      'body', message_body,
      'data', jsonb_build_object('matchId', NEW.match_id)
    ),
    'application/json',
    '{"Authorization": "Bearer <YOUR_SUPABASE_ANON_KEY>"}'
  );

  RETURN NEW;
END;
$$;

-- Trigger to call the function when a new message is inserted
CREATE TRIGGER on_new_message
  AFTER INSERT ON public.messages
  FOR EACH ROW EXECUTE PROCEDURE public.trigger_fcm_notification();
```

---

## Supabase Storage Setup

### For Post Images
1.  Go to the "Storage" section in your Supabase dashboard and create a **public** bucket named `post-images`.
2.  Add the policies from the SQL block in Part 4.

### For Chat Media (Images, Videos, Audio)
1.  Create another **public** bucket named `chat-media`.
2.  Add the policies from the SQL block in Part 5.
