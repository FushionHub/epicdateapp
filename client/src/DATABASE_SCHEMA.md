# Supabase Database Schema

This file contains the necessary SQL to set up the database tables for the dating application in your Supabase project.

## Instructions

1.  Navigate to your Supabase project dashboard.
2.  In the left sidebar, click on the "SQL Editor" icon.
3.  Click "New query".
4.  Copy the SQL code below and paste it into the SQL editor.
5.  Click "Run" to execute the query and create the tables and functions.

---

## Part 1: Profiles Table

This table stores the public profile information for each user.

```sql
-- Create the ringtones table first if it doesn't exist
CREATE TABLE IF NOT EXISTS public.ringtones (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  url TEXT NOT NULL
);

-- Seed with some default ringtones
INSERT INTO public.ringtones (name, url) VALUES
('Classic Phone', '/ringtones/classic.mp3'),
('Digital Alarm', '/ringtones/digital.mp3')
ON CONFLICT (name) DO NOTHING;


-- Create the profiles table
CREATE TABLE public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  name TEXT,
  username TEXT UNIQUE,
  age INT,
  bio TEXT,
  photos TEXT[],
  interests TEXT[],
  gender TEXT,
  preferences TEXT[],
  onboarding_complete BOOLEAN DEFAULT FALSE,
  is_verified BOOLEAN DEFAULT FALSE,
  subscription_tier TEXT DEFAULT 'free' NOT NULL,
  ringtone_id INT REFERENCES public.ringtones(id) DEFAULT 1,
  last_seen TIMESTAMPTZ DEFAULT now() NOT NULL,
  profile_score INT DEFAULT 0 NOT NULL,
  kyc_status TEXT DEFAULT 'not_started' NOT NULL -- ('not_started', 'pending', 'approved', 'rejected')
);

-- Add comments for clarity
COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';

-- Enable Row Level Security (RLS) for the profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
CREATE POLICY "Allow public read access" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Allow individual insert" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow individual update" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
```

---

## Part 2: Likes and Matches Tables

These tables handle the matchmaking logic.

```sql
-- Create the likes table
CREATE TABLE public.likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  liker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  liked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(liker_id, liked_id)
);

-- Enable RLS for likes
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

-- Policies for likes table
CREATE POLICY "Allow individual insert for likes" ON public.likes FOR INSERT WITH CHECK (auth.uid() = liker_id);
CREATE POLICY "Allow individual read for likes" ON public.likes FOR SELECT USING (auth.uid() = liker_id OR auth.uid() = liked_id);


-- Create the matches table
CREATE TABLE public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user1_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  user2_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  UNIQUE(user1_id, user2_id)
);

-- Enable RLS for matches
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;

-- Policies for matches table
CREATE POLICY "Allow individual read for matches" ON public.matches FOR SELECT USING (auth.uid() = user1_id OR auth.uid() = user2_id);
```

---

## Part 3: Database Function for Matching

This function handles the logic of creating a `like` and checking for a `match`.

```sql
-- Function to create a like and check for a match
CREATE OR REPLACE FUNCTION public.create_like_and_match(p_liked_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_liker_id UUID := auth.uid();
  v_match_exists BOOLEAN;
  v_new_match_id BIGINT;
BEGIN
  -- Insert the new like
  INSERT INTO public.likes (liker_id, liked_id)
  VALUES (v_liker_id, p_liked_id);

  -- Check if the other user has already liked the current user
  SELECT EXISTS (
    SELECT 1 FROM public.likes WHERE liker_id = p_liked_id AND liked_id = v_liker_id
  ) INTO v_match_exists;

  -- If a match exists, create a new match entry
  IF v_match_exists THEN
    INSERT INTO public.matches (user1_id, user2_id)
    VALUES (v_liker_id, p_liked_id)
    ON CONFLICT (user1_id, user2_id) DO NOTHING
    RETURNING id INTO v_new_match_id;

    RETURN json_build_object('matched', true, 'match_id', v_new_match_id);
  ELSE
    RETURN json_build_object('matched', false);
  END IF;
END;
$$;
```

---

## Part 4: Posts Table for Timeline/Feed

This table stores posts made by users.

```sql
-- Create the posts table
CREATE TABLE public.posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  text_content TEXT,
  image_url TEXT
);

-- Enable RLS for posts
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

-- Policies for posts table
CREATE POLICY "Allow public read access for posts" ON public.posts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for posts" ON public.posts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual update for posts" ON public.posts FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow individual delete for posts" ON public.posts FOR DELETE USING (auth.uid() = user_id);
```

---

## Part 5: Messages Table for Chat

This table stores all chat messages between matched users.

```sql
-- Create the messages table
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  match_id BIGINT NOT NULL REFERENCES public.matches(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  message_type TEXT NOT NULL DEFAULT 'text', -- 'text', 'image', 'video', 'audio'
  text_content TEXT,
  media_url TEXT,
  is_edited BOOLEAN DEFAULT false NOT NULL
);

-- Enable RLS for messages
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Function to check if a user is part of a match
CREATE OR REPLACE FUNCTION public.is_in_match(p_match_id BIGINT, p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.matches
    WHERE id = p_match_id AND (user1_id = p_user_id OR user2_id = p_user_id)
  );
$$;

-- Policies for messages table
CREATE POLICY "Allow read access to members of a match" ON public.messages FOR SELECT USING (is_in_match(match_id, auth.uid()));
CREATE POLICY "Allow insert access to members of a match" ON public.messages FOR INSERT WITH CHECK (is_in_match(match_id, auth.uid()) AND sender_id = auth.uid());
CREATE POLICY "Allow update access for sender" ON public.messages FOR UPDATE USING (auth.uid() = sender_id);
```

---

## Part 6: Monetization Tables & Functions

These tables provide the foundation for the wallet and subscription system.

```sql
-- Create a new ENUM type for currency
CREATE TYPE currency_type AS ENUM ('USD', 'NGN', 'EUR', 'GBP');

-- Create the wallets table
CREATE TABLE public.wallets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  currency currency_type NOT NULL,
  balance NUMERIC(12, 2) NOT NULL DEFAULT 0.00,
  UNIQUE(user_id, currency)
);

-- Enable RLS for wallets
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;

-- Policies for wallets
CREATE POLICY "Allow individual read access for wallets" ON public.wallets FOR SELECT USING (auth.uid() = user_id);


-- Create the transactions table
CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_id BIGINT NOT NULL REFERENCES public.wallets(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  transaction_type TEXT NOT NULL, -- e.g., 'deposit', 'gift_sent', 'subscription_fee'
  amount NUMERIC(12, 2) NOT NULL,
  description TEXT
);

-- Enable RLS for transactions
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- Policies for transactions
CREATE POLICY "Allow individual read access for transactions" ON public.transactions FOR SELECT USING (
  EXISTS (SELECT 1 FROM wallets WHERE id = wallet_id AND user_id = auth.uid())
);


-- Function to create wallets for a new user automatically
CREATE OR REPLACE FUNCTION public.create_user_wallets()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.wallets (user_id, currency)
  VALUES
    (NEW.id, 'NGN'),
    (NEW.id, 'USD'),
    (NEW.id, 'EUR'),
    (NEW.id, 'GBP');
  RETURN NEW;
END;
$$;

-- Trigger to call the function when a new profile is created
CREATE TRIGGER on_profile_created_wallets
  AFTER INSERT ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.create_user_wallets();

-- Create gift_types table
CREATE TABLE public.gift_types (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  cost NUMERIC(10, 2) NOT NULL,
  currency currency_type NOT NULL DEFAULT 'NGN',
  icon_url TEXT
);

-- Seed some default gifts
INSERT INTO public.gift_types (name, cost, currency, icon_url) VALUES
('Rose', 500.00, 'NGN', '/gifts/rose.png'),
('Diamond', 5000.00, 'NGN', '/gifts/diamond.png'),
('Teddy Bear', 2500.00, 'NGN', '/gifts/bear.png')
ON CONFLICT (name) DO NOTHING;

-- Create user_gifts table
CREATE TABLE public.user_gifts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  gift_type_id INT NOT NULL REFERENCES public.gift_types(id)
);

-- Enable RLS
ALTER TABLE public.user_gifts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read on gifts" ON public.user_gifts FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for gifts" ON public.user_gifts FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- Function to transfer funds between users
CREATE OR REPLACE FUNCTION public.transfer_funds(
  p_receiver_id UUID,
  p_amount NUMERIC,
  p_currency currency_type
)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_sender_id UUID := auth.uid();
  v_sender_wallet_id BIGINT;
  v_receiver_wallet_id BIGINT;
  v_sender_balance NUMERIC;
BEGIN
  -- Get sender's wallet and balance
  SELECT id, balance INTO v_sender_wallet_id, v_sender_balance
  FROM public.wallets
  WHERE user_id = v_sender_id AND currency = p_currency;

  -- Check for sufficient funds
  IF v_sender_balance IS NULL OR v_sender_balance < p_amount THEN
    RETURN 'Insufficient funds';
  END IF;

  -- Get receiver's wallet
  SELECT id INTO v_receiver_wallet_id
  FROM public.wallets
  WHERE user_id = p_receiver_id AND currency = p_currency;

  IF v_receiver_wallet_id IS NULL THEN
    RETURN 'Receiver does not have a wallet for this currency';
  END IF;

  -- Perform the transfer
  UPDATE public.wallets SET balance = balance - p_amount WHERE id = v_sender_wallet_id;
  UPDATE public.wallets SET balance = balance + p_amount WHERE id = v_receiver_wallet_id;

  -- Create transaction records
  INSERT INTO public.transactions (wallet_id, transaction_type, amount, description)
  VALUES
    (v_sender_wallet_id, 'transfer_sent', p_amount, 'Sent to ' || (SELECT name FROM profiles WHERE id = p_receiver_id)),
    (v_receiver_wallet_id, 'transfer_received', p_amount, 'Received from ' || (SELECT name FROM profiles WHERE id = v_sender_id));

  RETURN 'Transfer successful';
END;
$$;
```

---

## Part 7: Core Social Features Tables

```sql
-- Create the followers table
CREATE TABLE public.followers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  follower_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  following_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(follower_id, following_id)
);

-- Enable RLS
ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow public read on followers" ON public.followers FOR SELECT USING (true);
CREATE POLICY "Allow individual insert for followers" ON public.followers FOR INSERT WITH CHECK (auth.uid() = follower_id);
CREATE POLICY "Allow individual delete for followers" ON public.followers FOR DELETE USING (auth.uid() = follower_id);


-- Create the blocked_users table
CREATE TABLE public.blocked_users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  blocker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  blocked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(blocker_id, blocked_id)
);

-- Enable RLS
ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual access for blocked users" ON public.blocked_users FOR ALL
USING (auth.uid() = blocker_id)
WITH CHECK (auth.uid() = blocker_id);

-- Create the reports table
CREATE TABLE public.reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  reporter_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reported_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reason TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'resolved', 'dismissed'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual insert for reports" ON public.reports FOR INSERT
WITH CHECK (auth.uid() = reporter_id);
-- Note: An admin role would be needed to read/update reports. This is a basic setup.
```

---

## Part 8: KYC (Know Your Customer) Tables

```sql
-- Create the kyc_documents table
CREATE TABLE public.kyc_documents (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  document_type TEXT NOT NULL, -- e.g., 'passport', 'nin', 'bvn'
  document_url TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  reviewed_at TIMESTAMPTZ
);

-- Enable RLS
ALTER TABLE public.kyc_documents ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Allow individual to manage their own KYC docs" ON public.kyc_documents FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
```

---

## Supabase Storage Setup

### For Post Images
1.  Go to the "Storage" section in your Supabase dashboard and create a **public** bucket named `post-images`.

### For Chat Media (Images, Videos, Audio)
1.  Create another **public** bucket named `chat-media`.

### For Ringtones
1. Create a new **public** bucket named `ringtones`.

### For KYC Documents
1. Create a **private** bucket named `kyc-documents`. This is crucial for security.
2. Add policies to allow authenticated users to upload to their own folder:
   ```sql
   CREATE POLICY "Allow authenticated KYC uploads" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'kyc-documents' AND (storage.foldername(name))[1] = auth.uid()::text);
   CREATE POLICY "Allow individual read on KYC docs" ON storage.objects FOR SELECT USING (bucket_id = 'kyc-documents' AND (storage.foldername(name))[1] = auth.uid()::text);
   ```
